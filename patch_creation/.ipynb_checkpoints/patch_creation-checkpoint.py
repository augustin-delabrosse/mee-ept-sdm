"""
All docstrings and comments were generated by Claude Sonnet 4.
"""

import rasterio
import pandas as pd
import geopandas as gpd
from rasterio.transform import rowcol
import numpy as np
from rasterio.windows import Window
import os
import matplotlib.pyplot as plt
import glob
from tqdm import tqdm
from remote_sensing_utils import resample_dem_to_match, clip_vectors_to_image, _save_patch

class CreatePatches:
    """
    Class for generating and saving image and DEM patches from geospatial raster and vector data.
    """
    def __init__(self, image_path, dem_path, points_path, labels_path, output_dir, patch_size, site, campaign):
        """
        Initialize the CreatePatch class with paths and parameters for creating patches.

        Args:
            image_path (str): Path to the multispectral image (e.g., satellite image).
            dem_path (str): Path to the Digital Elevation Model (DEM) raster file.
            points_path (str): Path to the vector data file (geopackage or shapefile with points).
            labels_path (str): Path to a CSV file where labels will be saved.
            output_dir (str): Directory where patches and results will be saved.
            patch_size (int): Size of the square patch to extract (e.g., 256 means 256x256 pixels).
            site (str): Name or code of the study site.
            campaign (str): Name or code of the data collection campaign.

        Example of use:
        original_image_path = 'path_to_multispectral_image.tif'
        dsm_path = 'path_to_dsm_raster.tif'
        points_path = 'path_to_trap_locations.gpkg'
        output_dir = 'path_to_output_patches_directory/'
        patch_size = 512
        
        create_patches = CreatePatches(original_image_path, dsm_path, points_path, output_dir, patch_size)
        patches, dem_patches = create_patches.create_patches()
        create_patches.show_patches(output_dir + "image_patches/", num_patches=8, bands_to_show=[5, 3, 1])
        """
        self.image_path = image_path
        self.dem_path = dem_path
        self.points_path = points_path
        self.labels_path = labels_path
        self.output_dir = output_dir
        self.patch_size = patch_size
        self.site = site
        self.campaign = campaign

    @staticmethod
    def show_patches(patch_dir, num_patches=5, max_images_per_row=4, bands_to_show=[1]):
        """
        Display a few image patches for quick visual inspection.

        Args:
            patch_dir (str): Directory where patches are stored.
            num_patches (int): Number of patches to display.
            max_images_per_row (int): Maximum images to display per row.
            bands_to_show (list): List of band indices (1-based) to display.
                                  Use [1] for grayscale, [3,2,1] for RGB, etc.
        """
        # Ensure the user provides either 1 or 3 bands for display.
        if len(bands_to_show) not in [1, 3]:
            raise ValueError("Please provide exactly 1 or 3 bands for display.")

        # List and sort all patch file paths in the directory.
        patch_files = sorted(glob.glob(os.path.join(patch_dir, '*.tif')))
        selected_files = patch_files[:num_patches]  # Only display the requested number

        # Calculate required number of rows for the figure layout.
        num_rows = (len(selected_files) + max_images_per_row - 1) // max_images_per_row
        plt.figure(figsize=(15, num_rows * 5))  # Set figure size for readability

        for idx, patch_file in enumerate(selected_files):
            with rasterio.open(patch_file) as patch:
                # Read the requested bands from the image (bands are 1-based in rasterio)
                band_data = [patch.read(band) for band in bands_to_show]

                plt.subplot(num_rows, max_images_per_row, idx + 1)
                if len(bands_to_show) == 1:
                    # For grayscale display, show the single band
                    plt.imshow(band_data[0], cmap='gray', vmin=0, vmax=band_data[0].max())
                else:
                    # For RGB, stack three bands and normalize for visualization
                    rgb_image = np.stack(band_data, axis=-1)
                    rgb_image = np.clip(rgb_image, 0, 255)
                    rgb_image = (rgb_image - rgb_image.min()) / (rgb_image.max() - rgb_image.min()) * 255
                    rgb_image = rgb_image.astype(np.uint8)
                    plt.imshow(rgb_image)

                plt.title(f'Patch {idx + 1}')
                plt.axis('off')

        plt.tight_layout()
        plt.show()

    def create_patches(self, create_labels, dem_basename=None, image_folder_name='image_patches', dem_folder_name=None, resample=True, save_patches=True, save_dem_patches=True):
        """
        Create small image and DEM patches centered on each point in a reference vector file.

        Args:
            create_labels (bool): Whether to create/save a CSV file of labels for each patch.
            dem_basename (str): Basename for DEM output files (used for naming).
            image_folder_name (str): Directory name for saving image patches.
            dem_folder_name (str): Directory name for saving DEM patches.
            resample (bool): Whether to resample the DEM to match the image size/pixels.
            save_patches (bool): Whether to save the extracted image patches.
            save_dem_patches (bool): Whether to save the extracted DEM patches.

        Returns:
            tuple: (patches, dem_patches, labels) if create_labels, else (patches, dem_patches)
        """
        # Create output directories if they do not exist
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(self.output_dir + (dem_folder_name or ''), exist_ok=True)
        os.makedirs(self.output_dir + image_folder_name, exist_ok=True)

        # Open the main image and DEM files using rasterio
        with rasterio.open(self.image_path) as img_src:
            img_crs = img_src.crs  # Coordinate Reference System (CRS) of the image
            img_transform = img_src.transform  # Affine transform for location->pixel conversion
            img_bands = img_src.count  # Number of bands (channels) in the image
            img_bounds = img_src.bounds  # Bounding box of the image
            img_meta = img_src.meta  # Metadata for saving patches
            img_profile = img_src.profile  # Profile for saving patches
            img = img_src.read()  # Read the image into memory (array: bands x rows x cols)

        with rasterio.open(self.dem_path) as dem_src:
            dem_transform = dem_src.transform
            dem_profile = dem_src.profile
            dem = dem_src.read()  # DEM (elevation data)

        # Load vector data (e.g., sampling points) as a GeoDataFrame
        points_gdf = gpd.read_file(self.points_path)

        # Make sure that the vector points use the same CRS as the image
        if points_gdf.crs != img_crs:
            points_gdf = points_gdf.to_crs(img_crs)

        # Remove points that fall outside the image bounds for safety
        points_gdf = clip_vectors_to_image(points_gdf, img_bounds)

        # Optionally, resample the DEM to align with the multispectral image grid
        if resample:
            dem = resample_dem_to_match(
                src_path=self.dem_path,
                dest_transform=img_transform,
                dest_crs=img_crs,
                dest_width=img_meta['width'],
                dest_height=img_meta['height']
            )

        # If labels are required, prepare the DataFrame (create or load it)
        if create_labels:
            if not os.path.exists(self.labels_path):
                labels = pd.DataFrame(columns=["id", "site", "campaign", "ephemeroptera", "plecoptera", "trichoptera"])
            else:
                labels = pd.read_csv(self.labels_path, index_col="Unnamed: 0")

        patches = []      # List to store all image patches
        dem_patches = []  # List to store all DEM patches

        # Iterate over all points in the vector file (each is a patch center)
        for idx, point in tqdm(points_gdf.iterrows(), total=points_gdf.shape[0]):
            # Get the X/Y coordinates of the current point
            x, y = point.geometry.x, point.geometry.y

            # If labels will be created, extract label values from the point's attributes
            if create_labels:
                E = point.Nb_Ephemeropteres
                P = point.Nb_Plecopteres
                T = point.Nb_Trichopteres

            # Convert the geographic coordinates to image pixel indices
            px, py = rowcol(img_transform, x, y)

            # Calculate patch boundaries (ensuring they don't go negative)
            start_x = max(0, px - self.patch_size // 2)
            end_x = px + self.patch_size // 2
            start_y = max(0, py - self.patch_size // 2)
            end_y = py + self.patch_size // 2

            # Extract the patch from the image (all bands, for the chosen pixel window)
            patch = img[:, start_x:end_x, start_y:end_y]
            # Extract the corresponding DEM patch (assume single band or same as image)
            dem_patch = dem[:, start_x:end_x, start_y:end_y] if dem.ndim == 3 else dem[start_x:end_x, start_y:end_y]

            patches.append(patch)
            dem_patches.append(dem_patch)

            # If labels, add a new row to the DataFrame and save it
            if create_labels:
                labels.loc[labels.shape[0]+1, :] = [point.Name, self.site, self.campaign, E, P, T]
                labels.to_csv(self.labels_path)

            # Optionally, save the image patch to disk as a GeoTIFF file
            if save_patches:
                _save_patch(
                    patch=patch, 
                    profile=img_profile, 
                    index=point.Name,
                    base_name=f"{self.campaign}_{self.site}_patch", 
                    output_dir=self.output_dir + image_folder_name,
                )
            # Optionally, save the DEM patch to disk as a GeoTIFF file
            if save_dem_patches:
                _save_patch(
                    patch=dem_patch, 
                    profile=dem_profile, 
                    index=point.Name,
                    base_name=f"{self.campaign}_{self.site}_{dem_basename or ''}", 
                    output_dir=self.output_dir + (dem_folder_name or ''),
                    multispectrale=False
                )

        # Return all arrays and labels as needed
        if create_labels:
            return patches, dem_patches, labels
        else:
            return patches, dem_patches


def study_field_train_test_split(image_path, 
                                 points_path, 
                                 train_val_test=True, 
                                 test_split=0.2,
                                 val_split=0.2,
                                 image_basename=None, 
                                 image_output_dir=None, 
                                 points_basename=None, 
                                 points_output_dir=None, 
                                 save_splits=True, 
                                 save_gdf_modified=True):
    """
    Split an image and its corresponding shapefile of points into training, validation, and test sets based on their spatial location.
    The split is performed along the X axis (longitude).

    Args:
        image_path (str): Path to the input image (GeoTIFF).
        points_path (str): Path to the input points file (GeoPackage or shapefile).
        train_val_test (bool): If True, split into train/val/test; if False, only train/test.
        test_split (float): Fraction of points for the test set (default 0.2).
        val_split (float): Fraction of points for the validation set (default 0.2).
        image_basename (str): Basename for saving split images.
        image_output_dir (str): Output directory for split images.
        points_basename (str): Basename for saving the modified points shapefile.
        points_output_dir (str): Output directory for the modified points shapefile.
        save_splits (bool): If True, save split image files.
        save_gdf_modified (bool): If True, save the modified points file.

    Returns:
        tuple: (test_read, val_read, train_read, gdf) if train_val_test is True else (test_read, train_read, gdf)
    """
    # Load the point (vector) data as a GeoDataFrame
    gdf = gpd.read_file(points_path)
    # Compute the X coordinate for each point (used to sort spatially)
    gdf['x'] = gdf.geometry.x
    # Sort points from west to east, so we can split spatially
    gdf_sorted = gdf.sort_values(by="x")

    # Compute the number of points for test/validation sets
    num_test_points = int(np.ceil(gdf.shape[0] * test_split))
    num_val_points = int(np.ceil((gdf.shape[0] - num_test_points) * val_split)) if train_val_test else 0

    # Assign points to each split
    test_points = gdf_sorted[:num_test_points]
    val_points = gdf_sorted[num_test_points:num_test_points + num_val_points] if train_val_test else None
    train_points = gdf_sorted[num_test_points + num_val_points:] if train_val_test else gdf_sorted[num_test_points:]

    # Find the X coordinates for the division lines
    easternmost_test_x = test_points.geometry.x.max()
    westernmost_val_x = val_points.geometry.x.min() if train_val_test else None
    easternmost_val_x = val_points.geometry.x.max() if train_val_test else None
    westernmost_train_x = train_points.geometry.x.min()

    # Find the pixel coordinate at which to split the image
    division_x_test = (easternmost_test_x + (westernmost_val_x if train_val_test else westernmost_train_x)) / 2
    division_x_val = (easternmost_val_x + westernmost_train_x) / 2 if train_val_test else None

    # Open the original image
    with rasterio.open(image_path) as src:
        # Convert split X-coordinates to column indices (pixels)
        division_col_test = int((division_x_test - src.bounds.left) / src.res[0])
        division_col_val = int((division_x_val - src.bounds.left) / src.res[0]) if train_val_test else None

        width = src.width
        height = src.height

        # Define rasterio "windows" for each spatial region
        test_window = Window(0, 0, division_col_test, height)
        val_window = Window(division_col_test, 0, division_col_val - division_col_test, height) if train_val_test else None
        train_window = Window(division_col_val, 0, width - division_col_val, height) if train_val_test else Window(division_col_test, 0, width - division_col_test, height)

        # Read the actual pixel data for each region from disk
        test_read = src.read(window=test_window)
        val_read = src.read(window=val_window) if train_val_test else None
        train_read = src.read(window=train_window)

        # Optionally, save each region as a new GeoTIFF for further use
        if save_splits:
            os.makedirs(image_output_dir, exist_ok=True)
            os.makedirs(image_output_dir + "test/", exist_ok=True)
            if train_val_test:
                os.makedirs(image_output_dir + "val/", exist_ok=True)
            os.makedirs(image_output_dir + "train/", exist_ok=True)

            # Save test image (western part)
            test_output = image_output_dir + "test/" + f"{image_basename}_test.tif"
            with rasterio.open(
                test_output,
                "w",
                driver="GTiff",
                height=test_window.height,
                width=test_window.width,
                count=src.count,
                dtype=src.dtypes[0],
                crs=src.crs,
                nodata=-32767,
                transform=rasterio.windows.transform(test_window, src.transform),
            ) as dst:
                dst.write(test_read)

            # Save validation image (middle part)
            if train_val_test:
                val_output = image_output_dir + "val/" + f"{image_basename}_val.tif"
                with rasterio.open(
                    val_output,
                    "w",
                    driver="GTiff",
                    height=val_window.height,
                    width=val_window.width,
                    count=src.count,
                    dtype=src.dtypes[0],
                    crs=src.crs,
                    nodata=-32767,
                    transform=rasterio.windows.transform(val_window, src.transform),
                ) as dst:
                    dst.write(val_read)

            # Save train image (eastern part)
            train_output = image_output_dir + "train/" + f"{image_basename}_train.tif"
            with rasterio.open(
                train_output,
                "w",
                driver="GTiff",
                height=train_window.height,
                width=train_window.width,
                count=src.count,
                dtype=src.dtypes[0],
                crs=src.crs,
                nodata=-32767,
                transform=rasterio.windows.transform(train_window, src.transform),
            ) as dst:
                dst.write(train_read)

    # Define a simple function to assign each point to a region for the output shapefile
    def label_partition(x):
        if x < division_x_test:
            return "test"
        elif train_val_test and x < division_x_val:
            return "val"
        return "train"
    gdf["partition"] = gdf.x.apply(label_partition)

    # Optionally, save the updated points file (with "partition" column) to disk
    if save_gdf_modified:
        os.makedirs(points_output_dir, exist_ok=True)
        modified_shapefile_path = points_output_dir + f"{points_basename}.shp"
        gdf.to_file(modified_shapefile_path)

    if save_splits:
        print(f"Test{', validation,' if train_val_test else ''} and train TIFF parts saved in '{image_output_dir}'.")
    if save_gdf_modified:
        print(f"Modified shapefile saved as '{modified_shapefile_path}'.")

    return (test_read, val_read, train_read, gdf) if train_val_test else (test_read, train_read, gdf)